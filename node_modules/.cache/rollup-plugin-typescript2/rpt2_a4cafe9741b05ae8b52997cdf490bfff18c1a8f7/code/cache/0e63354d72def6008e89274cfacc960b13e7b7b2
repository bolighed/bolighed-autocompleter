{"code":"import { __decorate } from \"tslib\";\r\nimport * as React from 'react';\r\nimport { resolve, has, isFunction } from '@viewjs/utils';\r\nimport { AutoCompleteItem } from './autocompleter-item';\r\nimport { debounce, bind } from 'decko';\r\nexport class AutoCompleter extends React.PureComponent {\r\n    constructor(props) {\r\n        super(props);\r\n        this.input = React.createRef();\r\n        this.dropdown = React.createRef();\r\n        this.state = {\r\n            currentIndex: this.props.index || 0,\r\n            open: has(this.props, 'open') || false,\r\n            input: props.value ? props.value.toString() : void 0,\r\n            results: void 0,\r\n            isFetching: false,\r\n            showLoader: false,\r\n            selected: props.value,\r\n            placeholderActive: false\r\n        };\r\n        this._name = String.fromCharCode(65 + Math.floor(Math.random() * 26)) + Date.now() + this.props.name || '';\r\n    }\r\n    componentDidUpdate(prevProps, _prevState) {\r\n        if (prevProps.value != this.props.value) {\r\n            this.setState({\r\n                input: this.props.value ? this.props.value.toString() : void 0,\r\n                selected: this.props.value,\r\n            });\r\n        }\r\n    }\r\n    render() {\r\n        const dropdown = this._getDropdown();\r\n        let classNames = ['autocomplete-inner'];\r\n        if (this.state.input || this.state.placeholderActive)\r\n            classNames.push('placeholder-active');\r\n        if (this.props.showClearButton)\r\n            classNames.push('has-reset');\r\n        return React.createElement(\"div\", { className: `autocomplete ${this.state.open ? 'open' : ''}` + (this.state.results && this.state.results.length > 0 ? ' has-results' : '') },\r\n            React.createElement(\"div\", { className: classNames.join(' '), \"data-placeholder\": this.props.placeholder },\r\n                this.props.showClearButton ?\r\n                    this.state.input ? React.createElement(\"img\", { style: { cursor: 'pointer' }, src: \"/static/skuffesalg/images/search-delete.svg\", onClick: this._reset }) : React.createElement(\"img\", { src: \"/static/skuffesalg/images/search-icon.svg\" })\r\n                    : void 0,\r\n                React.createElement(\"div\", { className: `input__wrap ${(this.state.input || this.state.placeholderActive) ? 'placeholder-active' : ''}` },\r\n                    React.createElement(\"input\", { ref: this.input, type: \"text\", name: this._name, className: \"input\", id: this._name, value: this.state.input || '', autoFocus: this.props.autoFocus, autoComplete: this._name, disabled: this.props.disabled, onChange: e => {\r\n                            this._open();\r\n                            this.setState({ input: e.target.value }, () => {\r\n                                if (this.state.isFetching) {\r\n                                    this._fetchData();\r\n                                }\r\n                                else {\r\n                                    this._doQuery(this.state.input || '');\r\n                                }\r\n                            });\r\n                        }, onFocus: () => this.setState({ placeholderActive: true }), onBlur: () => {\r\n                            this.setState({ placeholderActive: false });\r\n                        }, onKeyDown: this._onKeyDown }),\r\n                    React.createElement(\"label\", { htmlFor: this._name, className: \"placeholder\" }, this.props.placeholder))),\r\n            dropdown && React.createElement(\"div\", { ref: this.dropdown, className: \"autocomplete-dropdown\" }, dropdown));\r\n    }\r\n    _onKeyDown(e) {\r\n        let scrollAmount = 36;\r\n        switch (e.keyCode) {\r\n            case 38 /* Up */:\r\n                e.preventDefault();\r\n                this.state.currentIndex >= 0 && this.setState({ currentIndex: this.state.currentIndex - 1 });\r\n                if (this.state.currentIndex > 4) {\r\n                    this.dropdown.current.scrollTop -= scrollAmount;\r\n                }\r\n                break;\r\n            case 9 /* Tab */:\r\n                // Ignore tab, if the dropdown is not open\r\n                if (!this.state.open)\r\n                    return;\r\n            case 40 /* Down */:\r\n                e.preventDefault();\r\n                if (e.shiftKey) {\r\n                    this.state.currentIndex > 0 && this.setState({ currentIndex: this.state.currentIndex - 1 });\r\n                }\r\n                else {\r\n                    const result = this.state.results || [];\r\n                    this.state.currentIndex < (result.length - 1) && this.setState({ currentIndex: this.state.currentIndex + 1 });\r\n                    if (this.state.currentIndex === 4) {\r\n                        this.dropdown.current.scrollTop = 15;\r\n                    }\r\n                    if (this.state.currentIndex > 4) {\r\n                        this.dropdown.current.scrollTop += scrollAmount;\r\n                    }\r\n                }\r\n                break;\r\n            case 27 /* Escape */:\r\n                e.preventDefault();\r\n                this._close(() => this.input.current.blur(), true);\r\n                break;\r\n            case 13 /* Return */:\r\n                // let list = this.state.input ? this.state.results : this.recentSearch.entries.reverse();\r\n                const list = this.state.results || [];\r\n                const current = list[this.state.currentIndex];\r\n                this._onSelection(current);\r\n                break;\r\n        }\r\n    }\r\n    _getDropdown() {\r\n        if (!this.state.open || (!this.state.input || this.state.input.length === 1))\r\n            return;\r\n        const list = this.state.results || [];\r\n        if (this.state.showLoader || (this.state.isFetching && list.length == 0)) {\r\n            return React.createElement(\"div\", { className: \"autocomplete-dropdown__inner\" },\r\n                React.createElement(\"div\", { className: \"loader\" },\r\n                    React.createElement(\"div\", { className: \"loader__wrapper\" },\r\n                        React.createElement(\"span\", { className: \"loader--spinner\" }))));\r\n        }\r\n        if (list.length === 0 && !this.state.showLoader && !this.state.selected && (this.state.input || '').length >= 2) {\r\n            return React.createElement(\"div\", { className: \"autocomplete-dropdown__inner\" },\r\n                React.createElement(\"div\", { className: \"not-found\" }, this.props.errorText || ''));\r\n        }\r\n        else if (!list.length || (this.state.input || '').length < 2)\r\n            return void 0;\r\n        const input = this.state.input.trim();\r\n        return React.createElement(\"div\", { className: \"autocomplete-dropdown__inner\" },\r\n            React.createElement(\"ul\", { className: \"autocomplete-list\" }, list.map((m, i) => {\r\n                if (isFunction(this.props.buildItem))\r\n                    return React.createElement(\"li\", { className: i === this.state.currentIndex ? 'selected' : '', onClick: _ => this._onSelection(m), key: m.key || m.id || m.toString() }, this.props.buildItem(m, i === this.state.currentIndex));\r\n                return React.createElement(AutoCompleteItem, { selected: i === this.state.currentIndex, entry: m, input: input, key: m.key || m.id || m.toString(), onClick: _ => this._onSelection(m) });\r\n            })));\r\n    }\r\n    _onBodyClicked(e) {\r\n        if (e.target.classList.contains('.autocomplete'))\r\n            return;\r\n        let parent = e.target.parentElement;\r\n        while (parent && parent.tagName != 'BODY') {\r\n            if (parent.classList.contains('autocomplete'))\r\n                return;\r\n            parent = parent.parentElement;\r\n        }\r\n        this._close(void 0);\r\n    }\r\n    _onSelection(entry) {\r\n        if (isFunction(this.props.onSelect)) {\r\n            this.props.onSelect(entry);\r\n        }\r\n        this._close();\r\n        this.setState({ input: entry.toString(), selected: entry });\r\n    }\r\n    _open() {\r\n        // Already open\r\n        if (this.state.open)\r\n            return;\r\n        //\r\n        document.querySelector('html').style.overflow = 'hidden';\r\n        document.body.removeEventListener('click', this._onBodyClicked);\r\n        document.body.addEventListener('click', this._onBodyClicked);\r\n        // html('html')\r\n        //     .addClass('overflow--hidden');\r\n        this.setState({ open: true });\r\n        // html(document.body).off('click', this._onBodyClicked, this);\r\n        // html(document.body)\r\n        //     .on('click', this._onBodyClicked, false, this);\r\n    }\r\n    _clear(cb) {\r\n        this.setState({ input: '', results: [], isFetching: false, showLoader: false, selected: void 0 }, cb);\r\n    }\r\n    _close(cb, clear = false) {\r\n        // html(document.body)\r\n        //     .off('click', this._onBodyClicked, this);\r\n        document.body.removeEventListener('click', this._onBodyClicked);\r\n        if (clear)\r\n            this._clear(() => this.setState({ open: false }, cb));\r\n        else {\r\n            let input = this.state.input ? this.state.selected ? this.state.selected.toString() : '' : '';\r\n            if (!input && this.state.selected) {\r\n                this._reset();\r\n            }\r\n            else {\r\n                this.setState({ open: false, input: input, selected: input ? this.state.selected : void 0 });\r\n            }\r\n        }\r\n        if (this.props.onClose) {\r\n            this.props.onClose();\r\n        }\r\n    }\r\n    _reset() {\r\n        this._close(this.props.onReset, true);\r\n    }\r\n    _doQuery(query) {\r\n        let done;\r\n        // We only wants to show the loader\r\n        // if the request takes more than ~500 ms.\r\n        const timer = setTimeout(() => {\r\n            done = +new Date();\r\n            this.setState({ showLoader: true });\r\n        }, 500);\r\n        if (!this.state.isFetching) {\r\n            this.setState({ isFetching: true });\r\n        }\r\n        else {\r\n            this.setState({ isFetching: false });\r\n        }\r\n        resolve(this.props.requestQuery, query).then(results => {\r\n            clearTimeout(timer);\r\n            this.setState({ showLoader: false });\r\n            if (results.length === 0) {\r\n                this.setState({ isFetching: false });\r\n            }\r\n            if (!this.state.showLoader)\r\n                this.setState({ results, open: true });\r\n            else {\r\n                let diff = (+new Date) - done;\r\n                if (diff < 1000) {\r\n                    setTimeout(() => {\r\n                        this.setState({ results });\r\n                    }, 500);\r\n                }\r\n                else {\r\n                    this.setState({ results });\r\n                }\r\n            }\r\n        }, e => {\r\n            clearTimeout(timer);\r\n            console.log('Got error from backend', e);\r\n            this.setState({ showLoader: false, isFetching: false, results: [] });\r\n        });\r\n        if (query === '') {\r\n            setTimeout(() => {\r\n                this.setState({ open: false });\r\n            }, 0);\r\n        }\r\n    }\r\n    _fetchData() {\r\n        this._doQuery(this.state.input);\r\n    }\r\n}\r\n__decorate([\r\n    bind\r\n], AutoCompleter.prototype, \"_onKeyDown\", null);\r\n__decorate([\r\n    bind\r\n], AutoCompleter.prototype, \"_onSelection\", null);\r\n__decorate([\r\n    bind\r\n], AutoCompleter.prototype, \"_close\", null);\r\n__decorate([\r\n    bind\r\n], AutoCompleter.prototype, \"_reset\", null);\r\n__decorate([\r\n    debounce(500)\r\n], AutoCompleter.prototype, \"_fetchData\", null);\r\n","references":["/home/rasmus/Development/Bo/bolighed-autocompleter/node_modules/@types/react/index.d.ts","/home/rasmus/Development/Bo/bolighed-autocompleter/node_modules/@viewjs/utils/lib/index.d.ts","/home/rasmus/Development/Bo/bolighed-autocompleter/src/constants.ts","/home/rasmus/Development/Bo/bolighed-autocompleter/src/types.ts","/home/rasmus/Development/Bo/bolighed-autocompleter/src/autocompleter-item.tsx","/home/rasmus/Development/Bo/bolighed-autocompleter/node_modules/decko/dist/decko.d.ts"],"dts":{"name":"/home/rasmus/Development/Bo/bolighed-autocompleter/autocompleter.d.ts","writeByteOrderMark":false,"text":"import * as React from 'react';\r\nimport { Resolvable } from '@viewjs/utils';\r\nimport { ToString } from './types';\r\nexport interface AutoCompleterProps<M extends ToString> {\r\n    name?: string;\r\n    className?: string;\r\n    requestQuery: Resolvable<M[], string>;\r\n    placeholder?: string;\r\n    index?: number;\r\n    open?: boolean;\r\n    value?: M;\r\n    autoFocus?: boolean;\r\n    disabled?: boolean;\r\n    showClearButton?: boolean;\r\n    onSelect?: (m: M) => any;\r\n    onClose?: () => any;\r\n    onBlur?: (e: React.FormEvent) => any;\r\n    onReset?: () => any;\r\n    buildItem?: (item: M, selected: boolean) => JSX.Element;\r\n    errorText?: string;\r\n}\r\nexport interface AutoCompleterState<M extends ToString> {\r\n    currentIndex: number;\r\n    open: boolean;\r\n    input: string | undefined;\r\n    results: M[] | undefined;\r\n    isFetching: boolean;\r\n    showLoader: boolean;\r\n    selected: M | undefined;\r\n    placeholderActive: boolean;\r\n}\r\nexport declare class AutoCompleter<M extends ToString> extends React.PureComponent<AutoCompleterProps<M>, AutoCompleterState<M>> {\r\n    input: React.RefObject<HTMLInputElement>;\r\n    dropdown: React.RefObject<HTMLDivElement>;\r\n    private _name;\r\n    constructor(props: AutoCompleterProps<M>);\r\n    componentDidUpdate(prevProps: AutoCompleterProps<M>, _prevState: AutoCompleterState<M>): void;\r\n    render(): JSX.Element;\r\n    private _onKeyDown;\r\n    private _getDropdown;\r\n    private _onBodyClicked;\r\n    private _onSelection;\r\n    private _open;\r\n    private _clear;\r\n    private _close;\r\n    private _reset;\r\n    private _doQuery;\r\n    _fetchData(): void;\r\n}\r\n"}}
